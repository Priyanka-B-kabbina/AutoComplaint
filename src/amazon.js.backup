/**
 * AutoComplaint Extension - Universal E-commerce Order Extraction
 * Universal, site-agnostic order page detection and data extraction
 * Works on Amazon, eBay, Flipkart, Myntra, and other e-commerce sites
 */

console.log('AutoComplaint: Universal E-commerce Order Extractor v8.0');

// Import DistilBERT MNLI Classifier
import DistilBERTMNLIClassifier from './distilbert-mnli-classifier.js';

// Also try global window fallback for browser environments
let ClassifierFallback = DistilBERTMNLIClassifier;
if (!ClassifierFallback && typeof window !== 'undefined') {
  ClassifierFallback = window.DistilBERTMNLIClassifier;
}

// Use the available classifier
const ClassifierClass = ClassifierFallback || DistilBERTMNLIClassifier;

// Global configuration
const CONFIG = {
  CONFIDENCE_THRESHOLD: 0.7,
  DEBUG_MODE: true,
  CACHE_DURATION: 5 * 60 * 1000 // 5 minutes
};

// ML Models - Standalone approach (no external server)
let models = {
  distilbertClassifier: null // Only DistilBERT MNLI for classification
};

let modelsReady = false;
const classificationCache = new Map();

/**
 * Initialize ML models for order detection and extraction
 */
async function initializeMLModels() {
  if (modelsReady) return models;
  
  try {
    console.log('ü§ñ Initializing standalone DistilBERT MNLI classifier...');
    
    // Load DistilBERT MNLI Order Page Classifier (STANDALONE)
    console.log('üß† Loading DistilBERT MNLI classifier...');
    try {
      if (!ClassifierClass) {
        throw new Error('DistilBERT MNLI Classifier not available');
      }

      models.distilbertClassifier = new ClassifierClass();
      await models.distilbertClassifier.loadModel();
      console.log('‚úÖ DistilBERT MNLI classifier loaded successfully');
    } catch (error) {
      console.error('‚ùå DistilBERT MNLI classifier failed to load:', error.message);
      throw error; // Don't continue without primary classifier
    }
    
    modelsReady = true;
    console.log('ÔøΩ Standalone ML model initialization completed');
    
    return models;
    
  } catch (error) {
    console.error('‚ùå Failed to initialize ML models:', error);
    modelsReady = true; // Still mark as ready to allow processing
    return models;
  }
}

/**
 * DistilBERT MNLI-based order page classification
 */
async function isOrderPageML(pageContent) {
  try {
    if (!models.distilbertClassifier) {
      throw new Error('DistilBERT MNLI classifier not available');
    }
    
    // Validate input content
    if (!pageContent || typeof pageContent !== 'string') {
      console.warn('‚ö†Ô∏è CLASSIFICATION - Invalid pageContent input:', {
        content: pageContent,
        type: typeof pageContent
      });
      throw new Error('Invalid page content for classification');
    }
    
    if (pageContent.trim().length < 5) {
      console.warn('‚ö†Ô∏è CLASSIFICATION - Page content too short for reliable classification:', pageContent.length);
      // For very short content, default to non-order page
      return {
        isOrder: false,
        confidence: 0.1,
        method: 'distilbert-mnli-short-content',
        details: {
          error: 'Content too short for classification',
          contentLength: pageContent.length
        }
      };
    }
    
    console.log('üß† Using DistilBERT MNLI for classification...');
    console.log('üîç CLASSIFICATION - Content being classified (first 200 chars):', pageContent.slice(0, 200));
    
    // Use DistilBERT MNLI classifier directly
    const result = await models.distilbertClassifier.classify(pageContent);
    
    console.log('ü§ñ DistilBERT MNLI Result:', {
      isOrder: result.isOrder,
      confidence: result.confidence.toFixed(3),
      topLabel: result.topLabel
    });
    
    return {
      isOrder: result.isOrder,
      confidence: result.confidence,
      method: 'distilbert-mnli',
      details: result
    };
    
  } catch (error) {
    console.error('‚ùå DistilBERT MNLI classification failed:', error.message);
    throw error;
  }
}

/**
 * Check if current page is an order page
 */
async function isOrderPage() {
  try {
    const url = window.location.href;
    console.log('üîç ANALYSIS START - Checking if page is an order page');
    console.log('üîç ANALYSIS - Current URL:', url);
    console.log('üîç ANALYSIS - Page title:', document.title);
    console.log('üîç ANALYSIS - Domain:', window.location.hostname);
    
    // Check cache first
    if (classificationCache.has(url)) {
      const cached = classificationCache.get(url);
      if (Date.now() - cached.timestamp < CONFIG.CACHE_DURATION) {
        console.log('üìã CACHE HIT - Using cached classification:', cached.result);
        return cached.result.isOrder;
      }
    }
    
    // Ensure models are ready
    if (!modelsReady) {
      console.log('üîÑ MODELS - Initializing ML models...');
      await initializeMLModels();
    }
    
    // Extract page content for classification
    console.log('üìÑ CONTENT - Extracting page content...');
    const pageContent = extractPageText();
    console.log('üìÑ CONTENT - Extracted text length:', pageContent.length);
    console.log('üìÑ CONTENT - First 300 characters:', pageContent.slice(0, 300));
    
    // Validate extracted content
    if (!pageContent || typeof pageContent !== 'string' || pageContent.length < 10) {
      console.warn('‚ö†Ô∏è CONTENT - Extracted content is invalid or too short:', {
        content: pageContent,
        type: typeof pageContent,
        length: pageContent?.length || 0
      });
      console.log('üîÑ CONTENT - Attempting alternative extraction...');
      
      // Try alternative extraction method
      const alternativeContent = document.title + ' ' + (document.body?.textContent || '').slice(0, 1000);
      if (alternativeContent.length > pageContent.length) {
        console.log('‚úÖ CONTENT - Using alternative content extraction');
        const cleanedAlternative = cleanAndNormalizeText(alternativeContent);
        if (cleanedAlternative.length >= 10) {
          console.log('üìÑ CONTENT - Alternative content length:', cleanedAlternative.length);
        }
      }
    }
    
    // Try ML classification first
    let result;
    try {
      console.log('ü§ñ CLASSIFICATION - Starting ML classification...');
      result = await isOrderPageML(pageContent);
      console.log('ü§ñ CLASSIFICATION - ML result:', result);
    } catch (error) {
      console.error('‚ùå CLASSIFICATION - ML classification failed:', error);
      console.warn('‚ö†Ô∏è ML classification failed, returning false for safety');
      
      // Cache the failed result to avoid repeated attempts
      const failedResult = {
        isOrder: false,
        confidence: 0,
        method: 'classification-failed',
        error: error.message
      };
      
      classificationCache.set(url, {
        result: failedResult,
        timestamp: Date.now()
      });
      
      return false;
    }
    
    // Cache the result
    classificationCache.set(url, {
      result,
      timestamp: Date.now()
    });
    console.log('üíæ CACHE - Result cached for future use');
    
    // Clean old cache entries
    cleanCache();
    
    // Log result
    if (CONFIG.DEBUG_MODE) {
      console.log('üéØ Page Classification Result:', {
        url: url.substring(0, 100),
        isOrder: result.isOrder,
        confidence: (result.confidence * 100).toFixed(1) + '%',
        method: result.method
      });
    }
    
    const isOrder = result.isOrder && result.confidence >= CONFIG.CONFIDENCE_THRESHOLD;
    
    if (isOrder) {
      console.log(`‚úÖ Order page detected with ${(result.confidence * 100).toFixed(1)}% confidence`);
    }
    
    return isOrder;
    
  } catch (error) {
    console.error('‚ùå Order page classification failed:', error);
    return false;
  }
}

/**
 * Extract page text content with intelligent, adaptive selectors
 * Uses a multi-layered approach to find order-related content on any e-commerce site
 */
function extractPageText() {
  console.log('üìÑ TEXT EXTRACTION - Starting universal, adaptive content extraction...');
  console.log('üìÑ TEXT EXTRACTION - Domain:', window.location.hostname);
  console.log('üìÑ TEXT EXTRACTION - Page title:', document.title);
  
  // Comprehensive list of elements to exclude (navigation, ads, etc.)
  const excludeSelectors = [
    'nav', 'header', 'footer', 'aside', 
    '[role="navigation"]', '[role="banner"]', '[role="contentinfo"]',
    '.navigation', '.nav', '.menu', '.header', '.footer', '.sidebar',
    '.advertisement', '.ad', '.ads', '.promo', '.promotion', '.banner',
    '.breadcrumb', '.breadcrumbs', '.tabs', '.tab', '.pagination',
    '.social-share', '.social', '.newsletter', '.subscription',
    '.cookie-notice', '.popup', '.modal', '.overlay', '.spinner',
    '.loading', '.skeleton', '.placeholder', '.tooltip',
    'script', 'style', 'noscript', 'iframe', 'embed', 'object'
  ];
  
  // Enhanced priority selectors for order content (universal patterns)
  const orderContentSelectors = [
    // Direct order/purchase identifiers
    '[class*="order"]', '[id*="order"]',
    '[class*="purchase"]', '[id*="purchase"]',
    '[class*="invoice"]', '[id*="invoice"]',
    '[class*="receipt"]', '[id*="receipt"]',
    '[class*="confirmation"]', '[id*="confirmation"]',
    '[class*="transaction"]', '[id*="transaction"]',
    
    // Order details and summaries
    '[class*="detail"]', '[id*="detail"]',
    '[class*="summary"]', '[id*="summary"]',
    '[class*="info"]', '[id*="info"]',
    
    // Shopping and checkout related
    '[class*="checkout"]', '[id*="checkout"]',
    '[class*="cart"]', '[id*="cart"]',
    '[class*="basket"]', '[id*="basket"]',
    
    // Payment and billing
    '[class*="payment"]', '[id*="payment"]',
    '[class*="billing"]', '[id*="billing"]',
    '[class*="shipping"]', '[id*="shipping"]',
    
    // Product and item related
    '[class*="product"]', '[id*="product"]',
    '[class*="item"]', '[id*="item"]',
    '[class*="goods"]', '[id*="goods"]'
  ];
  
  // Fallback content selectors
  const fallbackSelectors = [
    'main', '[role="main"]', '.main', '#main',
    '.content', '#content', '.main-content', '#main-content',
    '.container', '.wrapper', '.page', '.body-content',
    'article', 'section'
  ];
  
  let extractedContent = '';
  let contentSources = [];
  
  // Phase 1: Try order-specific selectors first
  console.log('üìÑ TEXT EXTRACTION - Phase 1: Searching order-specific content...');
  for (const selector of orderContentSelectors) {
    try {
      const elements = document.querySelectorAll(selector);
      if (elements.length > 0) {
        console.log(`üìÑ TEXT EXTRACTION - Found ${elements.length} elements for: ${selector}`);
        
        for (const element of elements) {
          // Skip if element is too small or likely irrelevant
          if (element.offsetHeight < 10 || element.offsetWidth < 10) continue;
          
          const cleanText = cleanElementText(element, excludeSelectors);
          if (cleanText.length > 30) { // Only consider substantial content
            extractedContent += cleanText + ' ';
            contentSources.push(selector);
            console.log(`üìÑ TEXT EXTRACTION - Added content from ${selector}: ${cleanText.slice(0, 100)}...`);
          }
        }
      }
    } catch (error) {
      console.warn(`üìÑ TEXT EXTRACTION - Error with selector ${selector}:`, error.message);
    }
  }
  
  // Phase 2: If minimal content found, try fallback selectors
  if (extractedContent.length < 200) {
    console.log('üìÑ TEXT EXTRACTION - Phase 2: Limited content found, trying fallback selectors...');
    
    for (const selector of fallbackSelectors) {
      try {
        const elements = document.querySelectorAll(selector);
        if (elements.length > 0) {
          console.log(`üìÑ TEXT EXTRACTION - Found ${elements.length} fallback elements for: ${selector}`);
          
          for (const element of elements) {
            const cleanText = cleanElementText(element, excludeSelectors);
            if (cleanText.length > 50) {
              extractedContent += cleanText + ' ';
              contentSources.push(selector);
              console.log(`üìÑ TEXT EXTRACTION - Added fallback content from ${selector}: ${cleanText.slice(0, 100)}...`);
              break; // Only take first substantial match for fallback
            }
          }
          
          if (extractedContent.length > 500) break; // Stop if we have enough content
        }
      } catch (error) {
        console.warn(`üìÑ TEXT EXTRACTION - Error with fallback selector ${selector}:`, error.message);
      }
    }
  }
  
  // Phase 3: Enhanced content analysis and filtering
  console.log('üìÑ TEXT EXTRACTION - Phase 3: Content analysis and filtering...');
  
  // Clean and normalize the extracted content
  extractedContent = cleanAndNormalizeText(extractedContent);
  
  // Phase 4: Ultimate fallback for very minimal content
  if (!extractedContent || extractedContent.length < 20) {
    console.warn('‚ö†Ô∏è TEXT EXTRACTION - Phase 4: Minimal content found, using enhanced fallback...');
    
    // Try to get any text from the page that might be relevant
    const bodyText = cleanElementText(document.body, excludeSelectors);
    const titleText = document.title || '';
    const urlText = window.location.href || '';
    
    // Combine available text sources
    extractedContent = `${titleText} ${bodyText} ${urlText}`.trim();
    extractedContent = cleanAndNormalizeText(extractedContent);
    contentSources.push('ultimate-fallback');
    
    // If still no content, provide a minimal default
    if (!extractedContent || extractedContent.length < 10) {
      extractedContent = `Page title: ${titleText || 'Unknown'} URL: ${urlText || 'Unknown'}`;
      console.warn('‚ö†Ô∏è TEXT EXTRACTION - Using minimal fallback content');
    }
  }
  
  // Limit content size for processing efficiency
  const maxLength = 8000; // Increased from 5000 for better extraction
  if (extractedContent.length > maxLength) {
    extractedContent = extractedContent.substring(0, maxLength);
    console.log(`üìÑ TEXT EXTRACTION - Content truncated to ${maxLength} characters`);
  }
  
  // Final analysis and reporting
  const orderKeywords = ['order', 'purchase', 'total', 'amount', 'price', 'date', 'customer', 'product', 'item', 'quantity', 'invoice', 'receipt', 'shipping', 'billing'];
  const foundKeywords = orderKeywords.filter(keyword => 
    extractedContent.toLowerCase().includes(keyword)
  );
  
  console.log('üìÑ TEXT EXTRACTION - Final content analysis:', {
    contentLength: extractedContent.length,
    contentSources: [...new Set(contentSources)],
    foundOrderKeywords: foundKeywords,
    keywordCount: foundKeywords.length,
    contentQuality: foundKeywords.length > 2 ? 'Good' : foundKeywords.length > 0 ? 'Fair' : 'Poor'
  });
  
  console.log('üìÑ TEXT EXTRACTION - Content preview (first 300 chars):', extractedContent.slice(0, 300));
  
  return extractedContent;
}

/**
 * Clean text from an element while excluding unwanted subelements
 */
function cleanElementText(element, excludeSelectors) {
  // Clone the element to avoid modifying the original DOM
  const clonedElement = element.cloneNode(true);
  
  // Remove excluded elements
  for (const excludeSelector of excludeSelectors) {
    const excludedElements = clonedElement.querySelectorAll(excludeSelector);
    excludedElements.forEach(el => el.remove());
  }
  
  // Get text content and clean it
  let text = clonedElement.textContent || '';
  
  // Remove excessive whitespace and normalize
  text = text.replace(/\s+/g, ' ').trim();
  
  return text;
}

/**
 * Advanced text cleaning and normalization
 */
function cleanAndNormalizeText(text) {
  console.log('üìÑ TEXT CLEANING - Starting advanced text cleanup...');
  
  // Validate input
  if (!text || typeof text !== 'string') {
    console.warn('‚ö†Ô∏è TEXT CLEANING WARNING - Invalid text input, returning empty string');
    return '';
  }
  
  try {
    // Remove excessive whitespace, tabs, newlines
    text = text.replace(/[\t\n\r\f\v]+/g, ' ');
    text = text.replace(/\s{2,}/g, ' ');
    
    // Remove empty parentheses, brackets
    text = text.replace(/\(\s*\)/g, '');
    text = text.replace(/\[\s*\]/g, '');
    text = text.replace(/\{\s*\}/g, '');
    
    // Remove repeated punctuation
    text = text.replace(/[.,;:!?]{2,}/g, '.');
    
    // Remove standalone single characters (except numbers and currency)
    text = text.replace(/\b[a-zA-Z]\b/g, '');
    
    // Remove excessive dots and dashes
    text = text.replace(/\.{2,}/g, '.');
    text = text.replace(/-{2,}/g, '-');
    
    // Clean up spaces around punctuation
    text = text.replace(/\s+([.,;:!?])/g, '$1');
    text = text.replace(/([.,;:!?])\s*([.,;:!?])/g, '$1');
    
    // Final cleanup
    text = text.replace(/\s+/g, ' ').trim();
    
    console.log('üìÑ TEXT CLEANING - Text cleanup completed');
    return text;
    
  } catch (error) {
    console.error('‚ùå TEXT CLEANING ERROR - Failed to clean text:', error);
    // Return original text if cleaning fails
    return (text || '').trim();
  }
}

/**
 * Clean old cache entries
 */
function cleanCache() {
  const now = Date.now();
  for (const [url, entry] of classificationCache.entries()) {
    if (now - entry.timestamp > CONFIG.CACHE_DURATION) {
      classificationCache.delete(url);
    }
  }
}

/**
 * Universal ML-based order information extraction
 * Works across all e-commerce platforms using adaptive patterns and selectors
 */
async function extractOrderInfoML(pageContent) {
  try {
    console.log('üîç UNIVERSAL EXTRACTION - Starting universal ML-based information extraction...');
    console.log('üîç UNIVERSAL EXTRACTION - Domain:', window.location.hostname);
    console.log('üîç UNIVERSAL EXTRACTION - Content length:', pageContent.length);
    
    const extractedData = {};
    
    // Phase 1: Universal selector-based extraction
    console.log('üìã PHASE 1 - Universal selector-based extraction...');
    
    const universalSelectors = {
      orderId: [
        // Order ID patterns
        '[class*="order"]', '[id*="order"]',
        '[class*="invoice"]', '[id*="invoice"]',
        '[class*="receipt"]', '[id*="receipt"]',
        '[data-field*="order"]', '[data-id*="order"]',
        'span[class*="number"]', 'div[class*="number"]',
        'strong', 'b', 'em', '.highlight'
      ],
      total: [
        // Price/total patterns
        '[class*="total"]', '[id*="total"]',
        '[class*="amount"]', '[id*="amount"]',
        '[class*="price"]', '[id*="price"]',
        '[class*="cost"]', '[id*="cost"]',
        '[class*="grand"]', '[class*="final"]',
        'span[class*="money"]', 'div[class*="money"]',
        '.currency', '.payment-amount'
      ],
      customerName: [
        // Customer/buyer information
        '[class*="customer"]', '[id*="customer"]',
        '[class*="buyer"]', '[id*="buyer"]',
        '[class*="user"]', '[id*="user"]',
        '[class*="name"]', '[id*="name"]',
        '[class*="shipping"]', '[id*="shipping"]',
        '[class*="billing"]', '[id*="billing"]'
      ],
      date: [
        // Date patterns
        '[class*="date"]', '[id*="date"]',
        '[class*="time"]', '[id*="time"]',
        '[class*="ordered"]', '[id*="ordered"]',
        '[class*="purchase"]', '[id*="purchase"]',
        'time', '[datetime]', '.timestamp'
      ],
      items: [
        // Product/item patterns
        '[class*="product"]', '[id*="product"]',
        '[class*="item"]', '[id*="item"]',
        '[class*="goods"]', '[id*="goods"]',
        '[class*="title"]', '[id*="title"]',
        'h1', 'h2', 'h3', 'h4', 'h5',
        '.product-title', '.item-title', '.product-name'
      ],
      seller: [
        // Seller/vendor patterns
        '[class*="seller"]', '[id*="seller"]',
        '[class*="vendor"]', '[id*="vendor"]',
        '[class*="merchant"]', '[id*="merchant"]',
        '[class*="store"]', '[id*="store"]',
        '[class*="brand"]', '[id*="brand"]'
      ],
      quantity: [
        // Quantity patterns
        '[class*="quantity"]', '[id*="quantity"]',
        '[class*="qty"]', '[id*="qty"]',
        '[class*="count"]', '[id*="count"]',
        '[class*="amount"]', '[id*="amount"]',
        'input[type="number"]', '.spinner'
      ]
    };
    
    // Extract each field using universal selectors
    for (const [fieldName, fieldSelectors] of Object.entries(universalSelectors)) {
      console.log(`üîç FIELD EXTRACTION - Searching for ${fieldName}...`);
      
      let fieldValues = new Set(); // Use Set to avoid duplicates
      
      for (const selector of fieldSelectors) {
        try {
          const elements = document.querySelectorAll(selector);
          
          for (const element of elements) {
            if (!element.textContent || !element.textContent.trim()) continue;
            
            let text = element.textContent.trim();
            
            // Apply field-specific cleaning and validation
            const cleanedValue = cleanFieldValue(text, fieldName);
            if (cleanedValue && cleanedValue.length > 0) {
              if (fieldName === 'items') {
                // For items, collect multiple values
                if (cleanedValue.length > 5 && cleanedValue.length < 200) {
                  fieldValues.add(cleanedValue);
                }
              } else {
                // For other fields, we want the best match
                fieldValues.add(cleanedValue);
              }
            }
          }
          
          // If we found values for this field, break to avoid redundancy
          if (fieldValues.size > 0 && fieldName !== 'items') break;
          
        } catch (error) {
          console.warn(`üìã SELECTOR ERROR - Error with selector ${selector}:`, error.message);
        }
      }
      
      // Store the extracted values
      if (fieldValues.size > 0) {
        if (fieldName === 'items') {
          extractedData[fieldName] = Array.from(fieldValues).slice(0, 10); // Limit to 10 items
        } else {
          // For single-value fields, pick the best candidate
          extractedData[fieldName] = selectBestFieldValue(Array.from(fieldValues), fieldName);
        }
        console.log(`‚úÖ FIELD FOUND - ${fieldName}:`, extractedData[fieldName]);
      }
    }
      
      for (const selector of fieldSelectors) {
        try {
          const elements = document.querySelectorAll(selector);
          if (elements.length > 0) {
            let values = [];
            
            for (const element of elements) {
              if (element.textContent && element.textContent.trim()) {
                let text = element.textContent.trim();
                
                // Clean up extracted text
                if (fieldName === 'total') {
                  // Extract price/amount
                  const priceMatch = text.match(/‚Çπ?[\d,]+\.?\d*/);
                  if (priceMatch) {
                    text = priceMatch[0];
                  }
                } else if (fieldName === 'orderId') {
                  // Extract order ID patterns
                  const orderMatch = text.match(/[A-Z0-9\-]{6,}/);
                  if (orderMatch) {
                    text = orderMatch[0];
    
    // Phase 2: Enhanced regex pattern extraction from page content
    console.log('üìã PHASE 2 - Enhanced regex pattern extraction...');
    
    const enhancedPatterns = {
      orderId: [
        /order[#\s]*:?\s*([A-Z0-9\-]{6,20})/gi,
        /invoice[#\s]*:?\s*([A-Z0-9\-]{6,20})/gi,
        /receipt[#\s]*:?\s*([A-Z0-9\-]{6,20})/gi,
        /transaction[#\s]*:?\s*([A-Z0-9\-]{6,20})/gi,
        /reference[#\s]*:?\s*([A-Z0-9\-]{6,20})/gi
      ],
      total: [
        /total[:\s]*[‚Çπ$‚Ç¨¬£¬•]?([\d,]+\.?\d*)/gi,
        /amount[:\s]*[‚Çπ$‚Ç¨¬£¬•]?([\d,]+\.?\d*)/gi,
        /grand\s*total[:\s]*[‚Çπ$‚Ç¨¬£¬•]?([\d,]+\.?\d*)/gi,
        /final\s*amount[:\s]*[‚Çπ$‚Ç¨¬£¬•]?([\d,]+\.?\d*)/gi,
        /[‚Çπ$‚Ç¨¬£¬•]([\d,]+\.?\d*)/g
      ],
      email: [
        /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})/g
      ],
      phone: [
        /(?:\+91[-\s]?)?[6789]\d{9}/g,
        /\+\d{1,3}[-\s]?\d{6,14}/g,
        /\(\d{3}\)[-\s]?\d{3}[-\s]?\d{4}/g
      ],
      date: [
        /\b\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}\b/g,
        /\b\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}\b/g,
        /\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]* \d{1,2},? \d{4}\b/gi
      ]
    };
    
    for (const [fieldName, patterns] of Object.entries(enhancedPatterns)) {
      if (!extractedData[fieldName]) { // Only extract if not already found
        for (const pattern of patterns) {
          const matches = pageContent.match(pattern);
          if (matches && matches.length > 0) {
            const cleanedValue = cleanFieldValue(matches[0], fieldName);
            if (cleanedValue) {
              extractedData[fieldName] = cleanedValue;
              console.log(`‚úÖ PATTERN FOUND - ${fieldName}:`, extractedData[fieldName]);
              break;
            }
          }
        }
      }
    }
    
    // Phase 3: Content analysis for missing fields
    console.log('üìã PHASE 3 - Content analysis for missing fields...');
    
    // If we still don't have key fields, try content analysis
    if (!extractedData.orderId || !extractedData.total) {
      const contentAnalysis = analyzeContentForMissingFields(pageContent, extractedData);
      Object.assign(extractedData, contentAnalysis);
    }
    
    // Add metadata
    extractedData.extractionMethod = 'universal-adaptive-ml';
    extractedData.timestamp = new Date().toISOString();
    extractedData.orderUrl = window.location.href;
    extractedData.domain = window.location.hostname;
    extractedData.extractedFieldCount = Object.keys(extractedData).filter(key => 
      !['extractionMethod', 'timestamp', 'orderUrl', 'domain'].includes(key)
    ).length;
    
    console.log('‚úÖ UNIVERSAL EXTRACTION - Extraction completed:', extractedData);
    console.log('üìä EXTRACTION SUMMARY:', {
      fieldsFound: extractedData.extractedFieldCount,
      method: extractedData.extractionMethod,
      hasOrderId: !!extractedData.orderId,
      hasTotal: !!extractedData.total,
      hasItems: !!extractedData.items?.length,
      domain: extractedData.domain
    });
    
    return extractedData;
    
  } catch (error) {
    console.error('‚ùå UNIVERSAL EXTRACTION ERROR - Extraction failed:', error);
    throw error;
  }
}

/**
 * Clean and validate field values based on field type
 */
function cleanFieldValue(text, fieldName) {
  if (!text || typeof text !== 'string') return null;
  
  text = text.trim();
  
  switch (fieldName) {
    case 'orderId':
      // Extract alphanumeric IDs, typically 6-20 characters
      const orderMatch = text.match(/[A-Z0-9\-]{6,20}/i);
      return orderMatch ? orderMatch[0] : null;
      
    case 'total':
      // Extract monetary amounts
      const amountMatch = text.match(/[‚Çπ$‚Ç¨¬£¬•]?([\d,]+\.?\d*)/);
      return amountMatch ? amountMatch[0] : null;
      
    case 'email':
      // Validate email format
      const emailMatch = text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/);
      return emailMatch ? emailMatch[0] : null;
      
    case 'phone':
      // Extract phone numbers
      const phoneMatch = text.match(/[\d\+\-\(\)\s]{10,}/);
      return phoneMatch ? phoneMatch[0].replace(/[^\d\+]/g, '') : null;
      
    case 'date':
      // Extract date patterns
      const dateMatch = text.match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}/);
      return dateMatch ? dateMatch[0] : null;
      
    case 'customerName':
      // Clean up names (remove titles, numbers)
      const nameMatch = text.match(/[A-Za-z\s]{2,50}/);
      return nameMatch ? nameMatch[0].trim() : null;
      
    case 'items':
      // Clean product names
      if (text.length > 5 && text.length < 200) {
        return text.replace(/[^\w\s\-]/g, '').trim();
      }
      return null;
      
    default:
      return text.length > 1 && text.length < 500 ? text : null;
  }
}

/**
 * Select the best value from multiple candidates for a field
 */
function selectBestFieldValue(values, fieldName) {
  if (!values || values.length === 0) return null;
  if (values.length === 1) return values[0];
  
  // Apply field-specific selection logic
  switch (fieldName) {
    case 'orderId':
      // Prefer longer, more complex IDs
      return values.sort((a, b) => b.length - a.length)[0];
      
    case 'total':
      // Prefer amounts with currency symbols
      const withCurrency = values.filter(v => /[‚Çπ$‚Ç¨¬£¬•]/.test(v));
      return withCurrency.length > 0 ? withCurrency[0] : values[0];
      
    case 'customerName':
      // Prefer names with multiple words
      const multiWord = values.filter(v => v.includes(' '));
      return multiWord.length > 0 ? multiWord[0] : values[0];
      
    default:
      // Default: return first value
      return values[0];
  }
}

/**
 * Analyze content for missing critical fields using advanced pattern matching
 */
function analyzeContentForMissingFields(content, existingData) {
  const missingFields = {};
  
  // Look for order-like patterns if order ID is missing
  if (!existingData.orderId) {
    const orderPatterns = [
      /\b[A-Z]{2,3}[\-]?\d{6,}\b/g,
      /\b\d{10,15}\b/g,
      /\b[A-Z0-9]{8,15}\b/g
    ];
    
    for (const pattern of orderPatterns) {
      const matches = content.match(pattern);
      if (matches && matches.length > 0) {
        missingFields.orderId = matches[0];
        console.log('üìã CONTENT ANALYSIS - Found potential order ID:', missingFields.orderId);
        break;
      }
    }
  }
  
  // Look for monetary amounts if total is missing
  if (!existingData.total) {
    const amountPatterns = [
      /[‚Çπ$‚Ç¨¬£¬•]\s?[\d,]+\.?\d*/g,
      /\b\d{2,6}\.\d{2}\b/g
    ];
    
    for (const pattern of amountPatterns) {
      const matches = content.match(pattern);
      if (matches && matches.length > 0) {
        missingFields.total = matches[0];
        console.log('üìã CONTENT ANALYSIS - Found potential total:', missingFields.total);
        break;
      }
    }
  }
  
  return missingFields;
}

/**
 * Initialize and run the main extraction process
 */
async function initializeExtraction() {
  try {
    console.log('üöÄ EXTRACTION START - AutoComplaint ML extraction process');
    console.log('üîç EXTRACTION - Current URL:', window.location.href);
    console.log('üîç EXTRACTION - Page title:', document.title);
    console.log('üîç EXTRACTION - Domain:', window.location.hostname);
    console.log('üîç EXTRACTION - Timestamp:', new Date().toISOString());
    
    // Analyze page structure first
    console.log('üìã PAGE ANALYSIS - Analyzing page structure...');
    const pageInfo = analyzePageStructure();
    console.log('üìã PAGE ANALYSIS - Results:', pageInfo);
    
    // Initialize ML models
    console.log('ü§ñ MODEL INIT - Initializing ML models...');
    await initializeMLModels();
    console.log('ü§ñ MODEL INIT - ML models ready');
    
    // Extract order information
    console.log('üì¶ DATA EXTRACTION - Starting order data extraction...');
    const extractedData = await extractOrderInfo();
    console.log('üì¶ DATA EXTRACTION - Raw extraction result:', extractedData);
    
    if (extractedData) {
      console.log('‚úÖ EXTRACTION SUCCESS - Order data extracted:', extractedData);
      console.log('üìä EXTRACTION STATS - Fields found:', Object.keys(extractedData).length);
      console.log('üìä EXTRACTION STATS - Has order ID:', !!extractedData.orderId);
      console.log('üìä EXTRACTION STATS - Has total:', !!extractedData.total);
      console.log('üìä EXTRACTION STATS - Has items:', !!extractedData.items?.length);
      
      // Save to chrome storage
      if (typeof chrome !== 'undefined' && chrome.storage) {
        chrome.storage.local.set({ autoComplaintOrder: extractedData }, () => {
          if (chrome.runtime.lastError) {
            console.error('‚ùå STORAGE ERROR:', chrome.runtime.lastError);
          } else {
            console.log('‚úÖ STORAGE SUCCESS - Order data saved to chrome storage');
          }
        });
      } else {
        console.log('üìã STORAGE SKIP - Chrome storage not available, data extracted only');
      }
      
      return extractedData;
    } else {
      console.log('‚ö†Ô∏è EXTRACTION EMPTY - No order data could be extracted from this page');
      console.log('üîç TROUBLESHOOT - Page might not be an order page or selectors need adjustment');
      return null;
    }
    
  } catch (error) {
    console.error('‚ùå EXTRACTION ERROR - Full extraction process failed:', error);
    console.error('‚ùå EXTRACTION ERROR - Stack trace:', error.stack);
    return null;
  }
}

/**
 * Run extraction when page is ready
 */
function startExtraction() {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeExtraction);
  } else {
    // Page already loaded
    initializeExtraction();
  }
}

/**
 * Watch for URL changes (SPA navigation)
 */
function watchForPageChanges() {
  let lastUrl = window.location.href;
  
  const observer = new MutationObserver(() => {
    if (window.location.href !== lastUrl) {
      lastUrl = window.location.href;
      console.log('üîÑ Page URL changed, re-running extraction...');
      setTimeout(initializeExtraction, 1000); // Small delay for page to load
    }
  });
  
  observer.observe(document.body, { 
    subtree: true, 
    childList: true 
  });
}

/**
 * Analyze page structure for debugging purposes
 */
function analyzePageStructure() {
  const analysis = {
    url: window.location.href,
    domain: window.location.hostname,
    title: document.title,
    hasOrderKeywords: false,
    orderKeywords: [],
    elementCounts: {},
    hasOrderElements: false,
    orderElements: [],
    suspectedOrderPage: false
  };

  // Check for order-related keywords in title and URL
  const orderKeywords = ['order', 'purchase', 'receipt', 'invoice', 'confirmation', 'thank you', 'checkout'];
  const combinedText = (document.title + ' ' + window.location.href).toLowerCase();
  
  analysis.orderKeywords = orderKeywords.filter(keyword => combinedText.includes(keyword));
  analysis.hasOrderKeywords = analysis.orderKeywords.length > 0;

  // Check for order-related elements
  const orderSelectors = [
    '.order', '.order-details', '.order-summary', '.order-info',
    '.receipt', '.invoice', '.confirmation', '.purchase-summary',
    '[class*="order"]', '[id*="order"]', '[class*="receipt"]', '[id*="receipt"]'
  ];

  for (const selector of orderSelectors) {
    const elements = document.querySelectorAll(selector);
    if (elements.length > 0) {
      analysis.orderElements.push({ selector, count: elements.length });
      analysis.elementCounts[selector] = elements.length;
    }
  }

  analysis.hasOrderElements = analysis.orderElements.length > 0;

  // Check common page elements
  analysis.elementCounts.headings = document.querySelectorAll('h1, h2, h3').length;
  analysis.elementCounts.forms = document.querySelectorAll('form').length;
  analysis.elementCounts.tables = document.querySelectorAll('table').length;
  analysis.elementCounts.lists = document.querySelectorAll('ul, ol').length;
  analysis.elementCounts.images = document.querySelectorAll('img').length;

  // Determine if this looks like an order page
  analysis.suspectedOrderPage = analysis.hasOrderKeywords || analysis.hasOrderElements;

  return analysis;
}

// Initialize the extension
console.log('üèÅ AutoComplaint ML extension loaded, starting extraction...');
startExtraction();
watchForPageChanges();

// Export functions for use by other modules
export { 
  initializeExtraction, 
  extractOrderInfo, 
  isOrderPage, 
  initializeMLModels 
};

// Expose functions for testing/debugging
if (typeof window !== 'undefined') {
  window.AutoComplaint = {
    extractOrderInfo,
    isOrderPage,
    initializeMLModels,
    initializeExtraction,
    models,
    CONFIG
  };
}
